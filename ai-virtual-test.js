// AI‰ªÆÊÉ≥Âãï‰ΩúÁ¢∫Ë™ç„Ç∑„Çπ„ÉÜ„É†
const fs = require('fs');

// „ÉÜ„Éà„É™„ÇπÂü∫Êú¨„ÇØ„É©„Çπ„ÅÆÁ∞°ÊòìÂÆüË£Ö
class Tetromino {
    constructor(type) {
        this.type = type;
        this.x = 3;
        this.y = 0;
        this.rotation = 0;
        this.shape = this.getShape(type);
        this.color = this.getColor(type);
    }
    
    getShape(type) {
        const shapes = {
            'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
            'O': [[1,1],[1,1]],
            'T': [[0,1,0],[1,1,1],[0,0,0]],
            'S': [[0,1,1],[1,1,0],[0,0,0]],
            'Z': [[1,1,0],[0,1,1],[0,0,0]],
            'J': [[1,0,0],[1,1,1],[0,0,0]],
            'L': [[0,0,1],[1,1,1],[0,0,0]]
        };
        return shapes[type] || shapes['I'];
    }
    
    getColor(type) {
        const colors = {
            'I': '#00f0f0', 'O': '#f0f000', 'T': '#a000f0',
            'S': '#00f000', 'Z': '#f00000', 'J': '#0000f0', 'L': '#f0a000'
        };
        return colors[type] || '#666666';
    }
    
    copy() {
        const newPiece = new Tetromino(this.type);
        newPiece.x = this.x;
        newPiece.y = this.y;
        newPiece.rotation = this.rotation;
        return newPiece;
    }
    
    rotate() {
        const oldShape = this.shape;
        const newShape = [];
        for (let x = 0; x < oldShape[0].length; x++) {
            newShape.push([]);
            for (let y = oldShape.length - 1; y >= 0; y--) {
                newShape[x].push(oldShape[y][x]);
            }
        }
        this.shape = newShape;
        this.rotation = (this.rotation + 1) % 4;
    }
}

class GameBoard {
    constructor(width = 10, height = 20) {
        this.width = width;
        this.height = height;
        this.grid = Array(height).fill().map(() => Array(width).fill(0));
    }
    
    isValidPosition(piece, x, y) {
        for (let py = 0; py < piece.shape.length; py++) {
            for (let px = 0; px < piece.shape[py].length; px++) {
                if (piece.shape[py][px] !== 0) {
                    const boardX = x + px;
                    const boardY = y + py;
                    
                    if (boardX < 0 || boardX >= this.width || 
                        boardY >= this.height || 
                        (boardY >= 0 && this.grid[boardY][boardX] !== 0)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    placePiece(piece) {
        for (let py = 0; py < piece.shape.length; py++) {
            for (let px = 0; px < piece.shape[py].length; px++) {
                if (piece.shape[py][px] !== 0) {
                    const boardX = piece.x + px;
                    const boardY = piece.y + py;
                    if (boardY >= 0 && boardY < this.height && boardX >= 0 && boardX < this.width) {
                        this.grid[boardY][boardX] = 1;
                    }
                }
            }
        }
    }
    
    getCompletedLines() {
        const completedLines = [];
        for (let y = 0; y < this.height; y++) {
            if (this.grid[y].every(cell => cell !== 0)) {
                completedLines.push(y);
            }
        }
        return completedLines;
    }
    
    clear() {
        this.grid = Array(this.height).fill().map(() => Array(this.width).fill(0));
    }
    
    // „Éú„Éº„ÉâÁä∂ÊÖã„ÅÆÂèØË¶ñÂåñ
    visualize() {
        console.log('  0123456789');
        for (let y = 0; y < this.height; y++) {
            const row = this.grid[y].map(cell => cell ? '‚ñà' : '¬∑').join('');
            console.log(`${y.toString().padStart(2)}${row}`);
        }
        console.log('  0123456789');
    }
}

// ‰øÆÊ≠£Ê∏à„ÅøAI„Ç≥„Éº„Éâ„ÇíË™≠„ÅøËæº„Åø
let TetrisAI;
try {
    const aiCode = fs.readFileSync('./src/autoplay.js', 'utf8');
    // Node.jsÁí∞Â¢ÉÁî®„Å´Ë™øÊï¥
    const modifiedCode = aiCode
        .replace(/console\.log/g, '// console.log') // „É≠„Ç∞„Çí‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñ
        .replace(/class TetrisAI/g, 'TetrisAI = class TetrisAI');
    
    eval(modifiedCode);
    console.log('‚úÖ TetrisAIË™≠„ÅøËæº„ÅøÊàêÂäü');
} catch (error) {
    console.log('‚ùå TetrisAIË™≠„ÅøËæº„ÅøÂ§±Êïó:', error.message);
    process.exit(1);
}

// AI‰ªÆÊÉ≥„ÉÜ„Çπ„Éà„Ç∑„Çπ„ÉÜ„É†
class AIVirtualTest {
    constructor() {
        this.ai = new TetrisAI();
        this.board = new GameBoard();
        this.totalLines = 0;
        this.totalPieces = 0;
        this.gameHistory = [];
    }
    
    log(message, level = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const prefix = {
            'info': 'üìã',
            'success': '‚úÖ',
            'warn': '‚ö†Ô∏è',
            'error': '‚ùå',
            'ai': 'ü§ñ'
        }[level] || 'üìã';
        
        console.log(`[${timestamp}] ${prefix} ${message}`);
    }
    
    // Âç±Èô∫„Å™„Éú„Éº„ÉâÁä∂Ê≥Å„Çí‰ΩúÊàêÔºà„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„ÅÆ„Çà„ÅÜ„Å™Áä∂Ê≥ÅÔºâ
    createDangerousBoard() {
        this.log('Âç±Èô∫„Å™„Éú„Éº„ÉâÁä∂Ê≥Å„Çí‰ΩúÊàê‰∏≠...', 'warn');
        
        // Â∫ï„Åã„Çâ15Ë°åÁõÆ„Åæ„Åß‰∏çË¶èÂâá„Å´ÈÖçÁΩÆÔºà„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„Å´Ëøë„ÅÑÁä∂Ê≥ÅÔºâ
        for (let y = 19; y >= 5; y--) {
            for (let x = 0; x < 10; x++) {
                // Á¥Ñ70%„ÅÆÁ¢∫Áéá„Åß„Éñ„É≠„ÉÉ„ÇØÈÖçÁΩÆ„ÄÅ„É©„É≥„ÉÄ„É†„Å™Á©¥„Çí‰Ωú„Çã
                if (Math.random() < 0.7) {
                    this.board.grid[y][x] = 1;
                }
            }
            // ÂêÑË°å„Å´Â∞ë„Å™„Åè„Å®„ÇÇ1„Å§„ÅØÁ©¥„ÇíÁ¢∫‰øù
            const emptySpots = [];
            for (let x = 0; x < 10; x++) {
                if (this.board.grid[y][x] === 0) emptySpots.push(x);
            }
            if (emptySpots.length === 0) {
                // Á©¥„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ1„Å§‰Ωú„Çã
                const randomX = Math.floor(Math.random() * 10);
                this.board.grid[y][randomX] = 0;
            }
        }
        
        this.log('Âç±Èô∫„Éú„Éº„Éâ‰ΩúÊàêÂÆå‰∫Ü', 'warn');
        this.analyzeBoard();
    }
    
    // ÂÆüÁî®ÁöÑ„Å™„ÉÜ„Çπ„Éà„Éú„Éº„Éâ‰ΩúÊàê
    createPracticalBoard() {
        this.log('ÂÆüÁî®ÁöÑ„Å™„Éú„Éº„ÉâÁä∂Ê≥Å„Çí‰ΩúÊàê‰∏≠...', 'info');
        
        // Â∫ï„Åã„Çâ5Ë°åÁ®ãÂ∫¶„Å´ÈÅ©Â∫¶„Å´ÈÖçÁΩÆ
        for (let y = 19; y >= 15; y--) {
            for (let x = 0; x < 10; x++) {
                if (Math.random() < 0.4) {
                    this.board.grid[y][x] = 1;
                }
            }
        }
        
        this.log('ÂÆüÁî®„Éú„Éº„Éâ‰ΩúÊàêÂÆå‰∫Ü', 'info');
        this.analyzeBoard();
    }
    
    // „Éú„Éº„ÉâÂàÜÊûê
    analyzeBoard() {
        const maxHeight = this.getMaxHeight();
        const avgHeight = this.getAverageHeight();
        const holes = this.countHoles();
        const completableLines = this.getCompletedLines().length;
        
        this.log(`„Éú„Éº„ÉâÂàÜÊûê - ÊúÄÈ´ò: ${maxHeight}, Âπ≥Âùá: ${avgHeight.toFixed(1)}, Á©¥: ${holes}, ÂÆåÊàêÂèØËÉΩ„É©„Ç§„É≥: ${completableLines}`);
    }
    
    getMaxHeight() {
        for (let y = 0; y < this.board.height; y++) {
            for (let x = 0; x < this.board.width; x++) {
                if (this.board.grid[y][x] !== 0) {
                    return this.board.height - y;
                }
            }
        }
        return 0;
    }
    
    getAverageHeight() {
        let totalHeight = 0;
        for (let x = 0; x < this.board.width; x++) {
            for (let y = 0; y < this.board.height; y++) {
                if (this.board.grid[y][x] !== 0) {
                    totalHeight += this.board.height - y;
                    break;
                }
            }
        }
        return totalHeight / this.board.width;
    }
    
    countHoles() {
        let holes = 0;
        for (let x = 0; x < this.board.width; x++) {
            let blockFound = false;
            for (let y = 0; y < this.board.height; y++) {
                if (this.board.grid[y][x] !== 0) {
                    blockFound = true;
                } else if (blockFound) {
                    holes++;
                }
            }
        }
        return holes;
    }
    
    getCompletedLines() {
        return this.board.getCompletedLines();
    }
    
    // AI„ÅÆÊà¶Áï•Ê±∫ÂÆö„ÉÜ„Çπ„Éà
    testAIStrategy() {
        this.log('=== AIÊà¶Áï•Ê±∫ÂÆö„ÉÜ„Çπ„Éà ===', 'ai');
        
        const strategy = this.ai.selectStrategy(this.board);
        this.log(`ÈÅ∏Êäû„Åï„Çå„ÅüÊà¶Áï•: ${strategy.name}`, 'ai');
        this.log(`ÂÑ™ÂÖàÈ†Ü‰Ωç: ${strategy.priority.join(' > ')}`, 'ai');
        
        return strategy;
    }
    
    // ÂÖ®„Éî„Éº„Çπ„Çø„Ç§„Éó„Åß„ÅÆAIÂà§Êñ≠„ÉÜ„Çπ„Éà
    testAllPieces() {
        this.log('=== ÂÖ®„Éî„Éº„Çπ„Çø„Ç§„Éó„Åß„ÅÆAIÂà§Êñ≠„ÉÜ„Çπ„Éà ===', 'ai');
        
        const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
        const results = [];
        
        for (const pieceType of pieces) {
            const piece = new Tetromino(pieceType);
            
            try {
                const startTime = Date.now();
                const bestMove = this.ai.calculateBestMove(this.board, piece, []);
                const thinkTime = Date.now() - startTime;
                
                results.push({
                    piece: pieceType,
                    move: bestMove,
                    thinkTime,
                    success: true
                });
                
                this.log(`${pieceType}„Éî„Éº„Çπ - ‰ΩçÁΩÆ:(${bestMove.x},${bestMove.rotation}) „Çπ„Ç≥„Ç¢:${bestMove.score?.toFixed(1)} ÊÄùËÄÉ:${thinkTime}ms`, 'ai');
                
            } catch (error) {
                results.push({
                    piece: pieceType,
                    error: error.message,
                    success: false
                });
                
                this.log(`${pieceType}„Éî„Éº„Çπ - „Ç®„É©„Éº: ${error.message}`, 'error');
            }
        }
        
        return results;
    }
    
    // ÂÆüÈöõ„ÅÆ„Ç≤„Éº„É†„Éó„É¨„Ç§„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
    simulateGameplay(maxPieces = 10) {
        this.log(`=== „Ç≤„Éº„É†„Éó„É¨„Ç§„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ (${maxPieces}Êâã) ===`, 'success');
        
        const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
        let placedPieces = 0;
        let linesCleared = 0;
        
        for (let i = 0; i < maxPieces; i++) {
            const pieceType = pieces[Math.floor(Math.random() * pieces.length)];
            const piece = new Tetromino(pieceType);
            
            this.log(`\n--- ${i + 1}ÊâãÁõÆ: ${pieceType}„Éî„Éº„Çπ ---`);
            
            try {
                // AIÂà§Êñ≠
                const bestMove = this.ai.calculateBestMove(this.board, piece, []);
                
                // „Éî„Éº„ÇπÁßªÂãï
                for (let r = 0; r < bestMove.rotation; r++) {
                    piece.rotate();
                }
                piece.x = bestMove.x;
                piece.y = bestMove.y;
                
                // ËêΩ‰∏ã‰ΩçÁΩÆË®àÁÆó
                while (this.board.isValidPosition(piece, piece.x, piece.y + 1)) {
                    piece.y++;
                }
                
                // ÈÖçÁΩÆ„ÉÅ„Çß„ÉÉ„ÇØ
                if (this.board.isValidPosition(piece, piece.x, piece.y)) {
                    this.board.placePiece(piece);
                    placedPieces++;
                    
                    // „É©„Ç§„É≥Ê∂àÂéª„ÉÅ„Çß„ÉÉ„ÇØ
                    const completedLines = this.board.getCompletedLines();
                    if (completedLines.length > 0) {
                        linesCleared += completedLines.length;
                        this.log(`üéâ ${completedLines.length}„É©„Ç§„É≥Ê∂àÂéªÔºÅ (ÂêàË®à: ${linesCleared}„É©„Ç§„É≥)`, 'success');
                        
                        // „É©„Ç§„É≥ÂâäÈô§
                        for (const lineY of completedLines.sort((a, b) => b - a)) {
                            this.board.grid.splice(lineY, 1);
                            this.board.grid.unshift(Array(this.board.width).fill(0));
                        }
                    } else {
                        this.log('„É©„Ç§„É≥Ê∂àÂéª„Å™„Åó');
                    }
                    
                    this.log(`ÈÖçÁΩÆÂÆå‰∫Ü - ‰ΩçÁΩÆ:(${piece.x},${piece.y}) ÂõûËª¢:${bestMove.rotation} „Çπ„Ç≥„Ç¢:${bestMove.score?.toFixed(1)}`);
                    this.analyzeBoard();
                    
                } else {
                    this.log('‚ùå „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº: „Éî„Éº„ÇπÈÖçÁΩÆ‰∏çÂèØ', 'error');
                    break;
                }
                
            } catch (error) {
                this.log(`‚ùå „Ç®„É©„Éº: ${error.message}`, 'error');
                break;
            }
        }
        
        this.log(`\n=== „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÁµêÊûú ===`, 'success');
        this.log(`ÈÖçÁΩÆ„Éî„Éº„ÇπÊï∞: ${placedPieces}`);
        this.log(`Ê∂àÂéª„É©„Ç§„É≥Êï∞: ${linesCleared}`);
        this.log(`ÂäπÁéá: ${linesCleared > 0 ? (linesCleared / placedPieces * 4).toFixed(3) : '0.000'}`);
        
        return {
            placedPieces,
            linesCleared,
            efficiency: linesCleared > 0 ? linesCleared / placedPieces * 4 : 0
        };
    }
    
    // ‰øÆÊ≠£ÂâçÂæå„ÅÆÊØîËºÉ„ÉÜ„Çπ„Éà
    compareStrategies() {
        this.log('=== ‰øÆÊ≠£ÂâçÂæå„ÅÆÊà¶Áï•ÊØîËºÉ ===', 'success');
        
        // Âç±Èô∫„Å™Áä∂Ê≥Å„Åß„ÅÆÊà¶Áï•„ÉÜ„Çπ„Éà
        this.createDangerousBoard();
        console.log('\n„ÄêÂç±Èô∫„Å™Áä∂Ê≥Å„Åß„ÅÆAIÂà§Êñ≠„Äë');
        this.board.visualize();
        
        const strategy = this.testAIStrategy();
        
        this.log('\n‰øÆÊ≠£Âæå„ÅÆÁâπÂæ¥:');
        this.log('- È´ò„Åï14‰ª•‰∏ä: Ë∂ÖÁ∑äÊÄ•Êà¶Áï•');
        this.log('- È´ò„Åï11‰ª•‰∏ä: Á∑äÊÄ•Êà¶Áï•');
        this.log('- È´ò„Åï8‰ª•‰∏ä: ÂÆâÂÖ®ÂÑ™ÂÖàÊà¶Áï•');
        this.log('- Perfect Clear: È´ò„Åï6‰ª•‰∏ã„ÅÆ„Åø');
        
        return strategy;
    }
    
    // Á∑èÂêà„ÉÜ„Çπ„ÉàÂÆüË°å
    runFullTest() {
        console.log('\nüéÆ === AI‰ªÆÊÉ≥Âãï‰ΩúÁ¢∫Ë™ç„Ç∑„Çπ„ÉÜ„É† ===\n');
        
        // 1. ‰øÆÊ≠£ÂÜÖÂÆπÁ¢∫Ë™ç
        this.log('‰øÆÊ≠£Ê∏à„ÅøAIË©ï‰æ°„Éë„É©„É°„Éº„ÇøÁ¢∫Ë™ç:', 'info');
        this.log(`- height: ${this.ai.evaluation.height} (Âº∑ÂåñÊ∏à„Åø)`);
        this.log(`- clear1: ${this.ai.evaluation.clear1} („É©„Ç§„É≥Ê∂àÂéªÊé®Â•®)`);
        this.log(`- clear4: ${this.ai.evaluation.clear4} („ÉÜ„Éà„É™„ÇπÊé®Â•®)`);
        
        // 2. Êà¶Áï•ÊØîËºÉ
        this.compareStrategies();
        
        // 3. ÂÆüÁî®„Éú„Éº„Éâ„Åß„ÅÆ„ÉÜ„Çπ„Éà
        this.log('\n=== ÂÆüÁî®„Éú„Éº„Éâ„Åß„ÅÆ„ÉÜ„Çπ„Éà ===', 'info');
        this.board.clear();
        this.createPracticalBoard();
        console.log('\n„ÄêÂÆüÁî®ÁöÑ„Å™Áä∂Ê≥Å„Åß„ÅÆAIÂà§Êñ≠„Äë');
        this.board.visualize();
        this.testAIStrategy();
        
        // 4. „Ç≤„Éº„É†„Éó„É¨„Ç§„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
        const result = this.simulateGameplay(20);
        
        // 5. Á∑èÂêàË©ï‰æ°
        this.log('\n=== Á∑èÂêàË©ï‰æ° ===', 'success');
        if (result.linesCleared > 0) {
            this.log('üéâ AI‰øÆÊ≠£ÊàêÂäüÔºÅ„É©„Ç§„É≥Ê∂àÂéª„ÇíÈÅîÊàêÔºÅ', 'success');
            this.log(`ÂäπÁéá: ${result.efficiency.toFixed(3)} (0.5‰ª•‰∏ä„ÅßËâØÂ•Ω)`, 'success');
        } else {
            this.log('‚ö†Ô∏è „Åæ„Å†ÊîπÂñÑ„ÅÆ‰ΩôÂú∞„Åå„ÅÇ„Çä„Åæ„Åô', 'warn');
        }
        
        return result;
    }
}

// „ÉÜ„Çπ„ÉàÂÆüË°å
const test = new AIVirtualTest();
test.runFullTest();